from __future__ import division
import sys, os, urllib, logging, jsonlib

# for rdflib
sys.path.insert(0, "/my/proj/ffg/lib/rdflib/build/lib.linux-i686-2.5/")

from twisted.application import internet, service
from twisted.python.util import sibpath
from twisted.web import http
from twisted.web.proxy import ReverseProxyResource
from twisted.web.client import getPage
from nevow import appserver, inevow, url
from nevow import loaders, rend, static, tags as T
from xml.utils import iso8601
from photos import Full, thumb, sizes
import rdflib
print "rdflib", rdflib.__version__
from rdflib.Graph import ConjunctiveGraph
from rdflib import Namespace, RDF, RDFS, Literal, Variable, URIRef
sys.path.append("/home/drewp/projects/ffg/sparqlhttp")
sys.path.append("/my/proj/ffg/sparqlhttp")
from sparqlhttp.dictquery import Graph2
from tagging import saveTags, getTags
import auth

log = logging.getLogger()

PHO = Namespace("http://photo.bigasterisk.com/0.1/")
SITE = Namespace("http://photo.bigasterisk.com/")
FOAF = Namespace("http://xmlns.com/foaf/0.1/")
SIOC = Namespace("http://rdfs.org/sioc/ns#")
DC = Namespace("http://purl.org/dc/elements/1.1/")
DCTERMS = Namespace("http://purl.org/dc/terms/")
SCOT = Namespace("http://scot-project.org/scot/ns#")
XS = Namespace("http://www.w3.org/2001/XMLSchema#")


myPicSubdirs = [d for d in os.listdir("/my/pic") if d != "~thumb"]

class ImagePage(rend.Page):
    def __init__(self, graph, uri):
        self.graph, self.uri = graph, uri

    def renderHTTP(self, ctx):
        # i don't have this page made up yet; just use imageset.py
        req = inevow.IRequest(ctx)
        req.redirect('http://photo.bigasterisk.com/set?current='+urllib.quote(self.uri, safe=''))
        return ''

    def render_large(self, ctx, data):
        return T.img(src=self.uri.replace('file:/my/pic','') + '?size=large')
    
    docFactory = loaders.stan(T.html[T.body[
        'page', T.directive("large"),
        ]])

class StaticCached(static.Data):
    """
    from http://twistedmatrix.com/pipermail/twisted-web/2005-March/001358.html
    """
    def __init__(self, data, mime, mtime):
        self.mtime = mtime
        static.Data.__init__(self, data, mime)
    def renderHTTP(self, ctx):
        request = inevow.IRequest(ctx)
        request.setLastModified(self.mtime)
        return static.Data.renderHTTP(self, ctx)

class Main(rend.Page):
    docFactory = loaders.stan(T.html[T.body[

T.h2["index_html"],
T.p["You're probably looking for ", T.a(href="harlan/")["Harlan's pictures"]],

        ]])
    
    def __init__(self, graph):
        self.graph = graph

    def httpAuthorized(self, ctx):
        request = inevow.IRequest(ctx)
        username, password = request.getUser(), request.getPassword()
        if username and password:
            userMatches = self.graph.queryd(
                """SELECT ?user WHERE { ?user pho:username ?u; pho:password ?p . }""",
                initBindings={Variable("u") : Literal(request.getUser()),
                              Variable("p") : Literal(request.getPassword())})
            if userMatches:
                return True
        return False

    def viewable(self, uri,  ctx):
        request = inevow.IRequest(ctx)

        openid = URIRef(request.getHeader('x-openid-proxy'))

        # not final; just matching the old logic
        if openid in auth.superusers:
            return True

        # somehow allow local clients who could get to the filesystem
        # anyway. maybe with a cookie file in the fs, or just ip
        # screening
        
#        if self.httpAuthorized(ctx):
#            return True

        if (self.graph.contains((uri, PHO['viewableBy'], PHO['friends']))
            or self.graph.contains((uri, PHO['viewableBy'], PHO['anyone']))):
            return True

        if self.graph.queryd("""
            SELECT ?post WHERE {
              <http://bigasterisk.com/ari/> sioc:container_of ?post .
              ?post sioc:links_to ?uri .
            }""", initBindings={Variable('uri') : uri}): # should just be ASK
            # this should also be limiting to readers of the blog!
            print "%s ok because it's on the blog" % uri
            return True
        
        # this capability doesn't appear in the make-public button
        topicViewableBy = set(r['vb'] for r in self.graph.queryd("""
        SELECT ?vb WHERE {
          ?uri foaf:depicts ?d .
          ?d pho:viewableBy ?vb .
          }
        """, initBindings={Variable("uri") : uri}))
        if (PHO['friends'] in topicViewableBy or
            PHO['anyone'] in topicViewableBy):
            return True

        return False

    def comments(self, uri, ctx, request):
        """take uri with /comments tail and proxy to the comment server"""
        assert uri.endswith('/comments')
        imgUri = URIRef(uri[:-len('/comments')])
        if not (
            (self.graph.contains((imgUri, RDF.type, FOAF['Image'])) and
            self.viewable(imgUri, ctx))):
            raise ValueError("%r is not a viewable image" % imgUri)

        request.uri = str(
            url.URL.fromString(request.uri).
            add('post', imgUri)#.
            #add('content', ctx.arg('content'))
            )
        #request.content = StringIO("")
        print "new req", request.uri

        return ReverseProxyResource("localhost", 9031, "/comments")

    def imageResource(self, uri, ctx):
        reqSize = ctx.arg('size')
        size = sizes.get(reqSize, 250)

        print "need thumb for", repr(uri)
        jpg, mtime = thumb(uri, size)

        return StaticCached(jpg, "image/jpeg", mtime)

    def nonViewable(self, request):
        #return self.needAuth(ctx), [] # for http auth
        request.setResponseCode(http.FORBIDDEN)
        # if it was an image, we should return a legal image here
          # this should pass our own url in a redirect
          # parameter to openid_proxy
        return '<a href="/login">openid login required</a>', []

    def locateChild(self, ctx, segments):
        request = inevow.IRequest(ctx)
        request.setHost('photo.bigasterisk.com', 80)

        # danger, user data!
        uri = SITE[urllib.quote('/'.join(segments))]
        log.debug("fetch uri %s", uri)
        if segments[0] in myPicSubdirs:

            if uri.endswith('/comments'):
                return self.comments(uri, ctx, request), []
            
            if self.graph.contains((uri, RDF.type, FOAF['Image'])):

                """
                proxy openid; now compare that header to the allowed viewers. if header is missing or empty, that becomes the 'anonymous' user. other openids are just URIRefs in the graph, and you have to be able to get from the viewableBy link to that URIRef (via any number of groups)

                in the url, take a tag to show. Display a checkbutton of whether the current image has that tag. Take key input to toggle the button. Post button changes as graph edits. click on the tag to go to an imageset of that tag.
"""
                
                if not self.viewable(uri, ctx):
                    return self.nonViewable(request)
                
                if ctx.arg('page'):
                    return ImagePage(graph, uri), ()

                return self.imageResource(uri, ctx), ()


        if segments[0] in ['2003', '2004', '2005', '2006', '2007', 
                           '2008', '2009']:
            its = lambda o: self.graph.contains((uri, RDF.type, o))
            if (its(PHO['Event']) or
                its(PHO['Place']) or
                its(PHO['Person']) or # oops
                its(FOAF['Person'])):

                if ctx.arg('random'):
                    import imageSet
                    reload(imageSet)
                    return imageSet.RandomImage(graph, uri, ctx), ()
                
                import imageSet
                reload(imageSet)
                return imageSet.ImageSet(ctx, graph, uri), ()
            print "uri %r not a searchable set" % uri

        return rend.Page.locateChild(self, ctx, segments)

    def needAuth(self, ctx):
        request = inevow.IRequest(ctx)
        request.setHeader('WWW-Authenticate', 'Basic realm="topsecret"')
        request.setResponseCode(http.UNAUTHORIZED)
        return "Authentication required."        

    def child_set(self, ctx):
        import imageSet
        reload(imageSet)

        if ctx.arg('dir'):
            topic = URIRef(ctx.arg('dir'))
        elif ctx.arg('tag'):
            topic = URIRef('http://photo.bigasterisk.com/tag/%s' % ctx.arg('tag'))
        elif ctx.arg('date'):
            topic = Literal(ctx.arg('date'), datatype=XS.date)
        elif ctx.arg('current'):
            topic = URIRef(ctx.arg('current'))
        else:
            raise ValueError("no topic")
        return imageSet.ImageSet(ctx, graph, topic)

    def child_events(self, ctx):
        import search
        reload(search)
        return search.Events(ctx, graph)

    def child_browse(self, ctx):
        import browse
        reload(browse)
        return browse.FileBrowse(ctx, graph)

    def child_edit(self, ctx, _name="Edit"):
        req = inevow.IRequest(ctx)
        user = URIRef(req.getHeader('x-openid-proxy'))
        if user not in auth.superusers:
            raise ValueError("forbidden")
        
        import edit
        reload(edit)
        return getattr(edit, _name)(ctx, graph)

    def child_edit2(self, ctx):
        return self.child_edit(ctx, _name="Edit2")

    def child_static(self, ctx):
        return static.File(sibpath(__file__, "static"))

    def child_comments(self, ctx):
        return ReverseProxyResource("localhost", 9031, "/comments")

    def child_oneImage(self, ctx):
        return ReverseProxyResource("localhost", 9043, "")

    def child_tagging(self, ctx):
        img = URIRef(ctx.arg('img'))
        req = inevow.IRequest(ctx)
        user = URIRef(inevow.IRequest(ctx).getHeader('x-foaf-agent'))
        if req.method == 'POST':
            saveTags(graph,
                     foafUser=user,
                     img=img,
                     tagString=ctx.arg('tags') or '',
                     desc=ctx.arg('desc') or '')
        
        inevow.IRequest(ctx).setHeader("Content-Type", "text/json")
        return jsonlib.dumps(getTags(graph, user, img))


    def child_makePublic(self, ctx):
        req = inevow.IRequest(ctx)
        if req.method != 'POST':
            raise ValueError("invalid method")
        return getPage('http://localhost:9043/viewPerm',
                       postdata=urllib.urlencode({'img' : ctx.arg('uri')}),
                       method='POST',
                       headers={'X-Foaf-Agent' :
                                inevow.IRequest(ctx).getHeader('x-foaf-agent')})


setattr(Main, "child_favicon.ico", static.File("static/favicon.ico"))

logging.basicConfig(level=logging.DEBUG)

initNs = dict(
        foaf=FOAF,
        rdfs=RDFS.RDFSNS,
        sioc=SIOC,
        pho=PHO,
        scot=SCOT,
        dc=DC,
    )

if 0:
    graph = Graph2(ConjunctiveGraph(), initNs=initNs)
else:
    from remotesparql import RemoteSparql
    graph = RemoteSparql("http://bang:8080/openrdf-sesame/repositories",
                         "photo", initNs=initNs)

application = service.Application('photo')
webServer = internet.TCPServer(8086, appserver.NevowSite(Main(graph)))
webServer.setServiceParent(application)
