from __future__ import division
import sys, os, md5, urllib, time, logging

# from /usr/share/doc/python-xml/changelog.Debian.gz
sys.path.append('/usr/lib/python%s/site-packages/oldxml' % sys.version[:3])

# for rdflib
sys.path.insert(0, "/my/proj/ffg/lib/rdflib/build/lib.linux-i686-2.5/")

from sets import Set
from StringIO import StringIO
from twisted.application import internet, service
from twisted.python.util import sibpath
from twisted.internet import reactor
from twisted.web import http
from nevow import appserver, inevow
from nevow import loaders, rend, static, tags as T
import Image
from photos import Full, thumb
import rdflib
print "rdflib", rdflib.__version__
from rdflib.Graph import ConjunctiveGraph
from rdflib import Namespace, RDF, RDFS, Literal, Variable, URIRef
sys.path.append("/my/proj/ffg/sparqlhttp")
from sparqlhttp.syncimport import SyncImport
from sparqlhttp.dictquery import Graph2

log = logging.getLogger()

PHO = Namespace("http://photo.bigasterisk.com/0.1/")
SITE = Namespace("http://photo.bigasterisk.com/")
FOAF = Namespace("http://xmlns.com/foaf/0.1/")

myPicSubdirs = ['digicam', 'phonecam', 'home', 'wedding']

class SyncImportFast(SyncImport):
    def allInputFiles(self):
        # faster to cull files more, here
        for root, dirs, files in os.walk(self.inputDirectory):
            for filename in files:
                # the dot hides emacs partial-save files, which i
                # didn't notice anyway
                if not filename.endswith(".n3") or filename.startswith('.'):
                    continue
                filename = os.path.join(root, filename)
                yield filename

class ImagePage(rend.Page):
    def __init__(self, graph, uri):
        self.graph, self.uri = graph, uri

    def render_large(self, ctx, data):
        return T.img(src=self.uri.replace('file:/my/pic','') + '?size=large')
    
    docFactory = loaders.stan(T.html[T.body[
        'page', T.directive("large"),
        ]])

class StaticCached(static.Data):
    """
    from http://twistedmatrix.com/pipermail/twisted-web/2005-March/001358.html
    """
    def __init__(self, data, mime, mtime):
        self.mtime = mtime
        static.Data.__init__(self, data, mime)
    def renderHTTP(self, ctx):
        request = inevow.IRequest(ctx)
        request.setLastModified(self.mtime)
        return static.Data.renderHTTP(self, ctx)

class Main(rend.Page):
    docFactory = loaders.stan(T.html[T.body[

T.h2["index_html"],
T.p["You're probably looking for ", T.a(href="harlan/")["Harlan's pictures"]],

        ]])
    
    def __init__(self, graph):
        self.graph = graph

    def httpAuthorized(self, ctx):
        request = inevow.IRequest(ctx)
        username, password = request.getUser(), request.getPassword()
        if username and password:
            userMatches = self.graph.queryd(
                """SELECT ?user WHERE { ?user pho:username ?u; pho:password ?p . }""",
                initBindings={Variable("u") : Literal(request.getUser()),
                              Variable("p") : Literal(request.getPassword())})
            if userMatches:
                return True
        return False

    def viewable(self, uri,  ctx):

        request = inevow.IRequest(ctx)

        openid = URIRef(request.getHeader('x-openid-proxy'))
        print "pxy", openid

        # not final; just matching the old logic
        if openid in [URIRef('http://bigasterisk.com/'),
                      URIRef('http://bigasterisk.com/kelsi/'),
                      ]:
            return True
        
#        if self.httpAuthorized(ctx):
#            return True

        return (self.graph.contains((uri, PHO['viewableBy'], PHO['friends']))
             or self.graph.contains((uri, PHO['viewableBy'], PHO['anyone'])))


    def locateChild(self, ctx, segments):
        request = inevow.IRequest(ctx)
        # danger, user data!
        uri = SITE['/'.join(segments)]
        log.debug("fetch uri %s", uri)
        if segments[0] in myPicSubdirs:
            if self.graph.contains((uri, RDF.type, FOAF['Image'])):
                if not self.viewable(uri, ctx):
                    #return self.needAuth(ctx), [] # for http auth
                    request.setResponseCode(http.FORBIDDEN)
                    return 'openid login required', []

                if ctx.arg('page'):
                    return ImagePage(graph, uri), ()

                reqSize = ctx.arg('size')
                size = {'thumb' : 75,
                        'medium' : 250,
                        'large' : 600,
                        'screen' : 1000,
                        'full' : Full}.get(reqSize, 250)

                jpg, mtime = thumb(uri, size)

                return StaticCached(jpg, "image/jpeg", mtime), ()

        if segments[0] in ['2003', '2004', '2005', '2006', '2007', 
                           '2008', '2009']:
            its = lambda o: self.graph.contains((uri, RDF.type, o))
            if (its(PHO['Event']) or
                its(PHO['Place']) or
                its(PHO['Person']) or # oops
                its(FOAF['Person'])):
                import imageSet
                reload(imageSet)
                return imageSet.ImageSet(ctx, graph, uri), ()
            print "uri %r not a searchable set" % uri

        return rend.Page.locateChild(self, ctx, segments)

    def needAuth(self, ctx):
        request = inevow.IRequest(ctx)
        request.setHeader('WWW-Authenticate', 'Basic realm="topsecret"')
        request.setResponseCode(http.UNAUTHORIZED)
        return "Authentication required."        

    def child_events(self, ctx):
        import search
        reload(search)
        return search.Events(ctx, graph)

    def child_browse(self, ctx):
        import browse
        reload(browse)
        return browse.FileBrowse(ctx, graph)

    def child_edit(self, ctx, _name="Edit"):
        if not self.httpAuthorized(ctx):
            return self.needAuth(ctx)
        import edit
        reload(edit)
        return getattr(edit, _name)(ctx, graph)

    def child_edit2(self, ctx):
        return self.child_edit(ctx, _name="Edit2")

    def child_static(self, ctx):
        return static.File(sibpath(__file__, "static"))

logging.basicConfig(level=logging.INFO)

initNs = dict(
        foaf=FOAF,
        rdfs=RDFS.RDFSNS,
        pho=PHO)

if 0:
    graph = Graph2(ConjunctiveGraph(), initNs=initNs)
else:
    from remotesparql import RemoteSparql
    graph = RemoteSparql("http://bang:8080/openrdf-sesame/repositories",
                         "photo", initNs=initNs)

application = service.Application('photo')
webServer = internet.TCPServer(8086, appserver.NevowSite(Main(graph)))
webServer.setServiceParent(application)
