from __future__ import division
import sys, os, urllib, logging, jsonlib

# for rdflib
sys.path.insert(0, "/my/proj/ffg/lib/rdflib/build/lib.linux-i686-2.5/")

from twisted.application import internet, service
from twisted.python.util import sibpath
from twisted.web import http
from twisted.web.proxy import ReverseProxyResource
from twisted.web.client import getPage
from twisted.internet.defer import inlineCallbacks, returnValue, Deferred
from nevow import appserver, inevow, url
from nevow import loaders, rend, static, tags as T
from xml.utils import iso8601
from photos import Full, thumb, sizes
import rdflib
print "rdflib", rdflib.__version__
from rdflib.Graph import ConjunctiveGraph
from rdflib import Namespace, RDF, RDFS, Literal, Variable, URIRef
import auth, networking
import access
from db import getGraph
log = logging.getLogger()
logging.getLogger('restkit.client').setLevel(logging.WARN)

PHO = Namespace("http://photo.bigasterisk.com/0.1/")
SITE = Namespace("http://photo.bigasterisk.com/")
FOAF = Namespace("http://xmlns.com/foaf/0.1/")
SIOC = Namespace("http://rdfs.org/sioc/ns#")
DC = Namespace("http://purl.org/dc/elements/1.1/")
DCTERMS = Namespace("http://purl.org/dc/terms/")
SCOT = Namespace("http://scot-project.org/scot/ns#")
XS = Namespace("http://www.w3.org/2001/XMLSchema#")


myPicSubdirs = [d for d in os.listdir("/my/pic") if d != "~thumb"]

class ImagePage(rend.Page):
    def __init__(self, graph, uri):
        self.graph, self.uri = graph, uri

    def renderHTTP(self, ctx):
        # i don't have this page made up yet; just use imageset.py
        req = inevow.IRequest(ctx)
        req.redirect('http://photo.bigasterisk.com/set?current='+urllib.quote(self.uri, safe=''))
        return ''

    def render_large(self, ctx, data):
        return T.img(src=self.uri.replace('file:/my/pic','') + '?size=large')
    
    docFactory = loaders.stan(T.html[T.body[
        'page', T.directive("large"),
        ]])

class StaticCached(static.Data):
    """
    from http://twistedmatrix.com/pipermail/twisted-web/2005-March/001358.html
    """
    def __init__(self, data, mime, mtime):
        self.mtime = mtime
        static.Data.__init__(self, data, mime)
    def renderHTTP(self, ctx):
        request = inevow.IRequest(ctx)
        request.setLastModified(self.mtime)
        request.setHeader('Cache-Control', 'max-age=604800')
        # flickr uses an even longer maxage, and puts on a Expires:
        # Mon, 28 Jul 2014 23:30:00 GMT, and then they have a squid
        # cache providing the image

        # For public requests, it would be nice to omit this so a
        # cache can give the image to two listeners. 
        # Note that this header is the only thing 'securing'
        # non-public requests, and it has to work with trusted
        # intermediate caches that aren't reachable by users, which is
        # unrealistic security.
        request.setHeader('Vary', 'Cookie')      

        return static.Data.renderHTTP(self, ctx)

class Main(rend.Page):
    docFactory = loaders.stan(T.html[T.body[

T.h2["index_html"],
T.p["You're probably looking for ", T.a(href="harlan/")["Harlan's pictures"]],

        ]])
    
    def __init__(self, graph):
        self.graph = graph

    def viewable(self, uri,  ctx):
        agent = access.getUser(ctx)
        return access.viewable(self.graph, uri, agent)

    def subresource(self, lastSegment, uri, ctx, request):
        """uri is some image, lastSegment is like /comments. This
        proxying might be done upstream by the webserver, so we can't
        add any other logic in here (including security checks!)

        the other server will always be passed a param 'uri' with the
        image uri
        """

        request.uri = str(
            url.URL.fromString(request.uri).
            add('uri', uri)
            )

        if lastSegment == 'comments':
            args = networking.commentProxy()
        elif lastSegment == 'facts': args = networking.serviceHost, 9043, '/facts'
        elif lastSegment == 'links': args = networking.serviceHost, 9043, '/links'
        elif lastSegment == 'tags': args = networking.serviceHost, 9043, '/tags'
        elif lastSegment == 'page':
            return ImagePage(graph, uri)
        else:
            raise NotImplementedError()

        return ReverseProxyResource(*args)

    def imageResource(self, uri, ctx):
        reqSize = ctx.arg('size')
        size = sizes.get(reqSize, 250)

        log.debug("need thumb for %r", uri)
        # this ought to return a redirect to a static error image when it breaks
        jpg, mtime = thumb(uri, size)

        return StaticCached(jpg, "image/jpeg", mtime)

    def nonViewable(self, request):
        """
        this shouldn't reveal whether the image was real or not-- just
        that there's nothing you can get to at your access level.
        """
        accept = request.getHeader('accept')
        ua = request.getHeader('user-agent')

        if (accept.split(',')[0].startswith('image/') or
            # http://code.google.com/p/chromium/issues/detail?id=63173
            ('Chromium' in ua and accept == '*/*')):
            log.info("failing with image")
            return open("static/noaccess.png").read()
        
        request.setHeader('WWW-Authenticate', 'Basic realm="topsecret"')
        request.setResponseCode(http.UNAUTHORIZED)
        #request.setResponseCode(http.FORBIDDEN)
        log.info("failing with text")
        # todo: login prompt if they weren't logged in; apology if they were
        return "Authentication required."        

    def locateChild(self, ctx, segments):
        request = inevow.IRequest(ctx)
        if 1:
            request.setHost('photo.bigasterisk.com', 80)

        uri = SITE[urllib.quote('/'.join(segments))]

        if segments[0] in myPicSubdirs:
            if segments[-1] in ['facts', 'page', 'links', 'comments',
                                'histogram', 'tags', 'description',
                                'sizes', 'access']:
                # danger, user data!
                uri = SITE[urllib.quote('/'.join(segments[:-1]))]
                return self.subresource(segments[-1], uri, ctx, request), []

            if self.graph.contains((uri, RDF.type, FOAF['Image'])):
                return self.imageChild(ctx, uri)
            
        if segments[0] in ['2003', '2004', '2005', '2006', '2007', 
                           '2008', '2009', '2010', '2011', '2012']:
            its = lambda o: self.graph.contains((uri, RDF.type, o))
            if (its(PHO['Event']) or
                its(PHO['Place']) or
                its(PHO['Person']) or # oops
                its(FOAF['Person'])):
                return self.topicChild(ctx, uri)
            print "uri %r not a searchable set" % uri

        return rend.Page.locateChild(self, ctx, segments)

    def imageChild(self, ctx, uri):
        """

        
        proxy openid; now compare that header to the allowed viewers. if header is missing or empty, that becomes the 'anonymous' user. other openids are just URIRefs in the graph, and you have to be able to get from the viewableBy link to that URIRef (via any number of groups)

        in the url, take a tag to show. Display a checkbutton of whether the current image has that tag. Take key input to toggle the button. Post button changes as graph edits. click on the tag to go to an imageset of that tag.
        """
        if not self.viewable(uri, ctx):
            request = inevow.IRequest(ctx)
            return self.nonViewable(request), ()

        if ctx.arg('page'): # old; use {img}/page now
            return ImagePage(graph, uri), ()

        return self.imageResource(uri, ctx), ()
        

    def topicChild(self, ctx, uri):
        if ctx.arg('random'):
            import imageSet
            reload(imageSet)
            return imageSet.RandomImage(self.graph, uri, ctx), ()

        if ctx.arg('edit'):
            return self.child_set(ctx), ()

        return self.makeStoryPage(uri), ()

    def makeStoryPage(self, topic):
        import story
        reload(story)
        class ret(rend.Page):
            def renderHTTP(self, ctx):
                req = inevow.IRequest(ctx)
                req.setHeader('Content-Type', 'application/xhtml+xml')
                cookie = inevow.IRequest(ctx).getHeader("cookie") or ''
                req.write(story.renderPage(graph, topic, access.getUser(ctx), 
                                           cookie))
                req.finish()
                return ''
        return ret()

    def child_set(self, ctx):
        import imageSet
        reload(imageSet)
        ua = inevow.IRequest(ctx).getHeader('user-agent')
        if 'iPad' in ua or ctx.arg('tablet') == '1':
            cls = imageSet.ImageSetTablet
        else:
            cls = imageSet.ImageSet
        return cls(ctx, graph, inevow.IRequest(ctx).uri)

    def child_events(self, ctx):
        import search
        reload(search)
        return search.Events(ctx, graph)

    def child_browse(self, ctx):
        import browse
        reload(browse)
        return browse.FileBrowse(ctx, graph)

    def child_edit(self, ctx, _name="Edit"):
        req = inevow.IRequest(ctx)
        user = URIRef(req.getHeader('x-openid-proxy'))
        if user not in auth.superusers:
            raise ValueError("forbidden")
        
        import edit
        reload(edit)
        return getattr(edit, _name)(ctx, graph)

    def child_edit2(self, ctx):
        return self.child_edit(ctx, _name="Edit2")

    def child_static(self, ctx):
        return static.File(sibpath(__file__, "static"))

    def child_aclChange(self, ctx):
        req = inevow.IRequest(ctx)
        if req.method != 'POST':
            raise ValueError("invalid method")

        user = access.getUser(ctx)
        agent = URIRef(ctx.arg('agent'))
        accessTo = URIRef(ctx.arg('accessTo'))
        op = ctx.arg('op')
        if op == 'allow':
            access.addAccess(graph, user, agent, accessTo)
            return returnJson({"msg" : "added", "agentState":True})
        elif op == 'deny':
            access.removeAccess(graph, user, agent, accessTo)
            return returnJson({"msg" : "removed", "agentState":False})
        else:
            raise NotImplementedError("op: %r" % op)

def returnJson(d):
    class ret(rend.Page):
        def renderHTTP(self, ctx):
            req = inevow.IRequest(ctx)
            req.setHeader('Content-Type', 'application/json')
            req.write(jsonlib.write(d))
            req.finish()
            return ''
    return ret()
    

setattr(Main, "child_favicon.ico", static.File("static/favicon.ico"))

logging.basicConfig(level=logging.DEBUG)

graph = getGraph()

application = service.Application('photo')
webServer = internet.TCPServer(8086, appserver.NevowSite(Main(graph)))
webServer.setServiceParent(application)
